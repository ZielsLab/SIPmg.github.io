---
author: "Pranav Sampara"
title: "SIPmg vignette"
date: "2023-01-05"
output: html_document
weight: 1
type: docs
---

<link href="/ZielsLab/SIPmg.github.io.gitrmarkdown-libs/pagedtable/css/pagedtable.css" rel="stylesheet" />
<script src="/ZielsLab/SIPmg.github.io.gitrmarkdown-libs/pagedtable/js/pagedtable.js"></script>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>The SIPmg R package was designed to enable the exploration and statistical analysis of qSIP metagenomics data. Particularly, this package allows the identification of isotope incorporators and quantifies isotopic enrichment.</p>
<p>Please check out this introductory vignette to qSIP metagenomics, before checking out vignettes on:</p>
<p><a href="#scaling-coverage-data">Coverage normalization and scaling based on linear regression model</a></p>
<p><a href="#sip-metagenomics-and-identification-of-isotope-incorporators">Identification of incorporators based on qSIP, ΔBD, or DESeq2 methods</a></p>
</div>
<div id="background" class="section level1">
<h1>Background</h1>
<p>This section introduces a bit of a background on the methodologies used in this pipeline, such as stable isotope probing, quantitative metagenomics, and quantitative stable isotope probing. References as a point of departure for more reading are also provided.</p>
<div id="stable-isotope-probing" class="section level2">
<h2>Stable isotope probing</h2>
<p>Stable isotope probing (SIP) targets active populations within complex microbiomes by providing growth substrates enriched in a heavy stable isotope of carbon, nitrogen, or oxygen. In DNA-SIP, the DNA of microbes actively incorporating the labelled substrate into their DNA during cell division and growth would become increasingly labelled and heavier compared to the microbes not incorporating the substrate into their DNA. Heavier DNA can be physically separated via isopycnic centrifugation on a CsCl gradient, followed by fractionation. Sequencing effort on the “heavier density fractions” could inform the identity and function of microbes that actively incorporated the isotopic substrate into their DNA. Thus, DNA-SIP is a powerful technique to link the identity and function of environmental microbes.</p>
<p>However, traditional DNA-SIP is only a qualitative technique to identify active microbial populations and no quantitative estimates of isotopic enrichment of DNA are provided. For instance, the distinction between labelled and unlabelled microbes is defined by density gradient regions, limiting the resolution of taxon-specific responses to labelled or unlabelled. Moreover, there exists a guanine-cytosine (GC) bias in conventional SIP studies. The native buoyant density of DNA can differ by as much as 0.05 g/mL over the range of GC contents that can occur in complex communities. Lighter GC-content genomes may not shift into the researcher-assigned “heavier density fractions”, while high GC-content genomes may fall in the “heavier density fractions” without any isotopic substrate assimilation. Thus, a qualitative analysis may mask the true incorporators and, worse, falsely identify non-incorporators as incorporators, skewing the analysis of the study.</p>
</div>
<div id="quantitative-metagenomics" class="section level2">
<h2>Quantitative metagenomics</h2>
<p>Although metagenomics offers a comprehensive account of the metabolic repertoire in an environment, typically, the data is compositional. Relative abundance of genes or taxa is estimated to determine microbial community dynamics, which is directly influenced by the dynamics of rest of the community. Even if a certain gene remains in the same concentration, its relative abundance changes if a certain other gene increases/decreases in concentration. Absolute abundance of gene/genome can be critical, for instance, in the surveillance of a pathogenic gene/genome in an environment. For quantitative measurements of microbial taxon absolute abundance in a given metagenomic sample, <a href="https://www.nature.com/articles/s41467-018-05555-0">Hardwick et al. (2018)</a> proposed synthetic spike-ins, or sequins, as internal reference standards. Reference standards in metagenomics can act as scaling factors to evaluate quantitative estimates of individual biological features, in this case, genes or genomes.</p>
</div>
<div id="quantitative-sip-qsip" class="section level2">
<h2>Quantitative SIP (qSIP)</h2>
<p>In quantitative SIP (qSIP), quantitative estimates of isotope incorporation, expressed as atom fraction excess (AFE), are calculated based on a mathematical model. Quantitative estimates of isotopic enrichment of DNA facilitate accurate and sensitive estimates of substrate uptake measurements, and growth and mortality rates of individual taxa in a complex community. Moreover, qSIP analysis is less susceptible to GC and enrichment biases, and taxon abundance, making it amenable to quantify isotopic incorporations in a complex community such as the activated sludge microbiome, with in-situ conditions. Integration of qSIP and quantitative metagenomics (qSIP metagenomics) facilitates the exploration of active microbial populations’ taxonomic and metabolic diversity with a quantitative estimate of their abundance and isotope incorporation.</p>
</div>
<div id="for-details-on-sip-quantitative-metagenomics-and-qsip-please-refer-to-the-following-works" class="section level2">
<h2>For details on SIP, quantitative metagenomics, and qSIP, please refer to the following works:</h2>
<div id="sip" class="section level3">
<h3>SIP</h3>
<p><a href="https://www.nature.com/articles/nprot.2007.109">Neufeld, Josh D., Jyotsna Vohra, Marc G. Dumont, Tillmann Lueders, Mike Manefield, Michael W. Friedrich, and J. Colin Murrell. 2007. “DNA Stable-Isotope Probing.” Nature Protocols 2 (4): 860–66.</a></p>
<p><a href="https://link.springer.com/article/10.1007/s00248-006-9125-x">Neufeld JD, Dumont MG, Vohra J, Murrell JC. Methodological considerations for the use of stable isotope probing in microbial ecology. Microbial Ecology 2007; 53: 435–442.</a></p>
<p><a href="https://journals.asm.org/doi/10.1128/AEM.02609-06">Buckley DH, Huangyutitham V, Hsu S-F, Nelson TA. Stable isotope probing with 15N achieved by disentangling the effects of genome G+ C content and isotope enrichment on DNA density. Applied and environmental microbiology 2007; 73: 3189–3195.</a></p>
</div>
<div id="quantitative-metagenomics-1" class="section level3">
<h3>Quantitative metagenomics</h3>
<p><a href="https://www.nature.com/articles/s41467-018-05555-0">Hardwick SA, Chen WY, Wong T, Kanakamedala BS, Deveson IW, Ongley SE, et al. Synthetic microbe communities provide internal reference standards for metagenome sequencing and analysis. Nature Communications 2018; 9: 3096.</a></p>
</div>
<div id="qsip" class="section level3">
<h3>qSIP</h3>
<p><a href="https://journals.asm.org/doi/10.1128/AEM.02280-15">Hungate BA, Mau RL, Schwartz E, Caporaso JG, Dijkstra P, Gestel N van, et al. Quantitative Microbial Ecology through Stable Isotope Probing. Appl Environ Microbiol 2015; 81: 7570–7581.</a></p>
<p><a href="https://journals.asm.org/doi/10.1128/mSystems.00151-20">Sieradzki ET, Koch BJ, Greenlon A, Sachdeva R, Malmstrom RR, Mau RL, et al. Measurement error and resolution in quantitative stable isotope probing: implications for experimental design. Msystems 2020; 5: e00151-20.</a></p>
</div>
<div id="htssip-r-package" class="section level3">
<h3>HTSSIP R package</h3>
<p><a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0189616">Youngblut ND, Barnett SE, Buckley DH. HTSSIP: An R package for analysis of high throughput sequencing data from nucleic acid stable isotope probing (SIP) experiments. PLOS ONE 2018; 13: e0189616.</a></p>
</div>
</div>
</div>
<div id="using-sipmg-r-package" class="section level1">
<h1>Using SIPmg R package</h1>
<p>This R package was designed to facilitate statistical analyses using SIP metagenomic data. Particularly, coverage and taxonomic classification of metagenome-assembled genomes and metadata of fractionated DNA is used to identify incorporators and quantify isotopic enrichment.</p>
<p>Overall, the package can perform the following:</p>
<ol style="list-style-type: decimal">
<li><p>Coverage normalization to absolute concentrations or relative coverage. Scaling of coverages to absolute abundances based on post-fractionation reference standards, called sequins.</p></li>
<li><p>Statistical analysis based on either of</p></li>
</ol>
<ul>
<li>AFE mathematical model by <a href="https://journals.asm.org/doi/10.1128/AEM.02280-15">Hungate et al. (2015)</a> or</li>
<li>Delta buoyant density <span class="math inline">\(AFE_{ΔBD}\)</span> = <span class="math inline">\(\frac{W_{Lab}- W_{Light}}{I_{max}}\)</span>. Where Imax is the maximum linear shift in DNA BD (upon 100% labeling), as discussed by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2595786/">Birnie and Rickwood (1978)</a></li>
<li>Analyses as offered by <a href="https://cran.r-project.org/web/packages/HTSSIP/index.html">HTS-SIP</a></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Data visualization for identification of isotope incorporators.</li>
</ol>
<div id="example-workflow" class="section level2">
<h2>Example workflow</h2>
<p>qSIP analysis is typically performed using sequins, MAG coverage, and MAG taxonomy is performed using this R markdown. Briefly, coverages are normalized, MAG coverages are then scaled based on linear regression models from sequin coverage and concentrations, a phyloseq object is created from MAG absolute concentrations and taxonomy (GTDB taxonomy output format is required) data. 
Note: Sequins that were spiked in the DNA-SIP fractions will be used in scaling and creating linear regression models for evaluating absolute MAG concentrations. Please see <code>sequin_scaling.R</code> 
For normalizing coverage values please see <code>pooling_funs.R</code> </p>
<p>This R markdown primarily uses <code>Tidyverse</code>, <code>phyloseq</code>, and <code>HTSSIP</code> packages 
This markdown uses functions from <code>functions_qSIP_MAGs.R</code> </p>
<p>For this data, MetaSIPSim (developed by <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-020-3372-6">Barnett et al, 2020</a>) was used to simulate a data set from a hypothetical SIP workflow performed on the MBARC-26 mock community (as defined in <a href="https://www.nature.com/articles/sdata201681">Singer et al, 2016</a>). The data set was further augmented with simulated post-fractionation sequin spike-ins and the data set was simulated to have all 26 organisms as incorporators. Some of the 26 organisms also had plasmids, which were assembled as distinct genomic units, adding the total genomic features in the simulated study to be 38</p>
<pre class="r"><code>#Load required libraries

list.of.packages &lt;- c(&quot;tidyverse&quot;, &quot;HTSSIP&quot;, &quot;ggpubr&quot;,&quot;data.table&quot;)
new.packages &lt;- list.of.packages[!(list.of.packages %in% installed.packages()[,&quot;Package&quot;])]
if(length(new.packages)) install.packages(new.packages, quiet = T, dependencies = T, repos = &quot;http://cran.us.r-project.org&quot;)

if (!require(&quot;BiocManager&quot;, quietly = TRUE))
    install.packages(&quot;BiocManager&quot;)
BiocManager::install(&quot;phyloseq&quot;)
#&gt; Bioconductor version 3.16 (BiocManager 1.30.19), R 4.2.2 (2022-10-31 ucrt)
#&gt; Warning: package(s) not installed when version(s) same as or greater than current; use
#&gt;   `force = TRUE` to re-install: &#39;phyloseq&#39;
#&gt; Installation paths not writeable, unable to update packages
#&gt;   path: C:/Program Files/R/R-4.2.2/library
#&gt;   packages:
#&gt;     boot, foreign, Matrix
#&gt; Old packages: &#39;BiocParallel&#39;, &#39;blogdown&#39;, &#39;broom&#39;, &#39;cli&#39;, &#39;DESeq2&#39;, &#39;digest&#39;,
#&gt;   &#39;distinct&#39;, &#39;doRNG&#39;, &#39;formatR&#39;, &#39;genefilter&#39;, &#39;GenomeInfoDb&#39;,
#&gt;   &#39;GenomicRanges&#39;, &#39;ggbeeswarm&#39;, &#39;ggpmisc&#39;, &#39;htmlwidgets&#39;, &#39;isoband&#39;, &#39;locfit&#39;,
#&gt;   &#39;maptools&#39;, &#39;nlme&#39;, &#39;purrr&#39;, &#39;RSQLite&#39;, &#39;Rttf2pt1&#39;, &#39;scuttle&#39;, &#39;shiny&#39;,
#&gt;   &#39;testthat&#39;, &#39;xfun&#39;

BiocManager::install(&quot;EBImage&quot;)
#&gt; Bioconductor version 3.16 (BiocManager 1.30.19), R 4.2.2 (2022-10-31 ucrt)
#&gt; Warning: package(s) not installed when version(s) same as or greater than current; use
#&gt;   `force = TRUE` to re-install: &#39;EBImage&#39;
#&gt; Installation paths not writeable, unable to update packages
#&gt;   path: C:/Program Files/R/R-4.2.2/library
#&gt;   packages:
#&gt;     boot, foreign, Matrix
#&gt; Old packages: &#39;BiocParallel&#39;, &#39;blogdown&#39;, &#39;broom&#39;, &#39;cli&#39;, &#39;DESeq2&#39;, &#39;digest&#39;,
#&gt;   &#39;distinct&#39;, &#39;doRNG&#39;, &#39;formatR&#39;, &#39;genefilter&#39;, &#39;GenomeInfoDb&#39;,
#&gt;   &#39;GenomicRanges&#39;, &#39;ggbeeswarm&#39;, &#39;ggpmisc&#39;, &#39;htmlwidgets&#39;, &#39;isoband&#39;, &#39;locfit&#39;,
#&gt;   &#39;maptools&#39;, &#39;nlme&#39;, &#39;purrr&#39;, &#39;RSQLite&#39;, &#39;Rttf2pt1&#39;, &#39;scuttle&#39;, &#39;shiny&#39;,
#&gt;   &#39;testthat&#39;, &#39;xfun&#39;

library(tidyverse)
#&gt; ── Attaching packages
#&gt; ───────────────────────────────────────
#&gt; tidyverse 1.3.2 ──
#&gt; ✔ ggplot2 3.4.0      ✔ purrr   0.3.5 
#&gt; ✔ tibble  3.1.8      ✔ dplyr   1.0.10
#&gt; ✔ tidyr   1.2.1      ✔ stringr 1.5.0 
#&gt; ✔ readr   2.1.3      ✔ forcats 0.5.2 
#&gt; ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
#&gt; ✖ dplyr::filter() masks stats::filter()
#&gt; ✖ dplyr::lag()    masks stats::lag()
library(phyloseq)
library(HTSSIP)
library(ggpubr)
library(SIPmg)
#&gt; 
#&gt; Attaching package: &#39;SIPmg&#39;
#&gt; 
#&gt; The following objects are masked from &#39;package:HTSSIP&#39;:
#&gt; 
#&gt;     DESeq2_l2fc, HRSIP


set.seed(seed = 1000)</code></pre>
</div>
<div id="load-required-data" class="section level2">
<h2>Load required data</h2>
<p>The following files are required: </p>
<div id="mag-coverage-data" class="section level3">
<h3>MAG coverage data</h3>
<p>Pooled coverages data as a comma separated file (.csv file) across samples for <code>Features</code> including sequins that were used as spike-ins. The followings columns are required: </p>
<ol style="list-style-type: decimal">
<li><p>Feature: A character string describing the <code>Feature</code> label</p></li>
<li><p>Sample: The label for these n number of columns should be in the format of “‘isotope’_rep_#_fraction_#”. For instance, “12C_rep_1_fraction_1”. The number of sample columns should be the same as the product of (replicates, fractions, isotopes)</p></li>
</ol>
</div>
<div id="sequin-metadata" class="section level3">
<h3>Sequin metadata</h3>
<p>Load the sequins metadata as a comma separated file (.csv file) which has the following columns: </p>
<ol style="list-style-type: decimal">
<li><p>Feature: As described above</p></li>
<li><p>Length: Length of the sequin in bp</p></li>
<li><p>GC_content: GC content of the sequin</p></li>
<li><p>Sequence: Sequin nucleotide sequence</p></li>
<li><p>Concentration: Concentration of the sequin in attamoles/uL</p></li>
</ol>
</div>
<div id="dilutions-data" class="section level3">
<h3>Dilutions data</h3>
<p>Load dilutions data as a comma separated file (.csv file) that contains the following columns </p>
<ol style="list-style-type: decimal">
<li><p>Sample: Similar to the sample name as described above.</p></li>
<li><p>Dilution: Dilution of sequins added to the fraction before sequencing.</p></li>
</ol>
</div>
<div id="fractions-metadata" class="section level3">
<h3>Fractions metadata</h3>
<p>A fractions file as a comma separated file (.csv file) with the following columns: </p>
<ol style="list-style-type: decimal">
<li><p>Replicate: Depends on how many replicates the study has </p></li>
<li><p>Fractions: Typically in the range of 1-24 </p></li>
<li><p>Buoyant_density: As calculated from the refractometer for each fraction and replicate </p></li>
<li><p>Isotope - “12C”, “13C”, “14N”, “15N” etc. </p></li>
<li><p>DNA_concentration </p></li>
<li><p>Sample - In the format “‘isotope’_rep_#_fraction_#”. For instance 12C_rep_1_fraction_1 </p></li>
</ol>
</div>
<div id="gtdb-style-taxonomy-data" class="section level3">
<h3>GTDB style taxonomy data</h3>
<p>A taxonomy file in the GTDB output format (.tsv format). Load the bacteria and archaea taxonomy outputs separately. The markdown requires loading the standard output files from GTDB-Tk separately for bacteria and archaea</p>
</div>
<div id="mag-absolute-concentrations" class="section level3">
<h3>MAG absolute concentrations</h3>
<p>MAG absolute concentrations obtained from scaling_sequins.R. 
<code>mag_tab</code> object obtained from the above script is to be used as the input here</p>
</div>
<div id="gc-content" class="section level3">
<h3>GC content</h3>
<p>GC content of the MAGs as a comma separated file (.csv file). The table should contain the following columns: </p>
<ol style="list-style-type: decimal">
<li><p>OTU: MAG identifier such as the <code>Feature</code> label from the <code>sequin_scaling.R</code> script </p></li>
<li><p>GC_content: GC content of the <code>Feature</code> in the range of 0-1 </p></li>
</ol>
</div>
<div id="log-scale-boolean" class="section level3">
<h3>Log scale BOOLEAN</h3>
<p>True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale </p>
</div>
<div id="coefficient-of-variation" class="section level3">
<h3>Coefficient of variation</h3>
<p>Acceptable coefficient of variation for coverage and detection (eg. 20 for 20 % threshold of coefficient of variation)</p>
<p>Coverages above the threshold value will be flagged in the plots. Here a value of 20 is used. </p>
<pre class="r"><code>## Load data
#Coverage metadata
#Uncomment if your coverage data is in the format mentioned above for this file. Remains commented if you are using the output from `checkm coverage`
f_tibble &lt;- readr::read_csv(&quot;mock_input_data/coverage_metadata.csv&quot;)
#&gt; Rows: 124 Columns: 61
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr  (1): Feature
#&gt; dbl (60): 12C_rep_1_fraction_10, 12C_rep_1_fraction_1, 12C_rep_1_fraction_2,...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

#Sequins metadata
sequins &lt;- readr::read_csv(file=&quot;mock_input_data/sequins_metadata.csv&quot;)
#&gt; Rows: 115 Columns: 5
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (2): Feature, Sequence
#&gt; dbl (3): Length, GC_content, Concentration
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

#Dilutions data
seq_dil = readr::read_csv(file = &quot;mock_input_data/dilutions_data.csv&quot;)
#&gt; Rows: 60 Columns: 2
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): Sample
#&gt; dbl (1): Dilution
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

#Log scale BOOLEAN. True or False depending on how you would want the MAG coverages to be scaled. Select TRUE if you need MAG concentrations scaled on the log scale
log_scale = TRUE

#coe_of_variation. Acceptable coefficient of variation for coverage and detection (eg. 20 - for 20 % threshold of coefficient of variation) (Coverages above the threshold value will be flagged in the plots)
coe_of_variation = 20 

#Taxonomy
gtdbtk_bac_summary = readr::read_delim(&quot;mock_input_data/gtdbtk.bac120.summary.tsv&quot;, 
                                 &quot;\t&quot;, escape_double = FALSE, trim_ws = TRUE)
#&gt; Rows: 33 Columns: 19
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;\t&quot;
#&gt; chr  (2): user_genome, classification
#&gt; lgl (17): fastani_reference, fastani_reference_radius, fastani_taxonomy, fas...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
gtdbtk_archaea = readr::read_delim(&quot;mock_input_data/gtdbtk.ar122.summary.tsv&quot;, 
                             &quot;\t&quot;, escape_double = FALSE, trim_ws = TRUE)
#&gt; Rows: 5 Columns: 19
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;\t&quot;
#&gt; chr  (2): user_genome, classification
#&gt; lgl (17): fastani_reference, fastani_reference_radius, fastani_taxonomy, fas...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#GC content
GC_content &lt;- readr::read_csv(file = &quot;mock_input_data/GC_content.csv&quot;)
#&gt; Rows: 38 Columns: 2
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): OTU
#&gt; dbl (1): Gi
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.

#Fractions
fractions = readr::read_csv(&quot;mock_input_data/fractions.csv&quot;)
#&gt; Rows: 60 Columns: 6
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (2): Isotope, Sample
#&gt; dbl (4): Replicate, Fraction, Buoyant_density, DNA_concentration(ng/uL)
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
</div>
</div>
<div id="coverage-normalization-and-scaling" class="section level2">
<h2>Coverage normalization and scaling</h2>
<p>Coverage data of MAGs (or features of interest) and sequins is scaled using sequin concentration to obtain absolute concentration of MAGs (or features of interest). For this step, either linear regression or robust linear regression can be used.</p>
<p>If linear regression is used, the function <code>scale_features_lm</code> is used. The functions in <code>sequin_scaling_lm.R</code> are used for this step.</p>
<p>If robust linear regression is used, the outliers impact on the regression models is minimized. For robust linear regression, <code>scale_features_rlm</code> is used. The functions in <code>sequin_scaling_rlm.R</code> are used for this step. In this example workflow, robust linear regression is used to scale coverage data in log10 scale.</p>
<p>For more discussion on the choice of regression method and comparison of the two methods please see this <a href="#scaling-coverage-data">vignette</a></p>
<div id="this-function-uses-the-following-datasets" class="section level3">
<h3>This function uses the following datasets:</h3>
<ol style="list-style-type: decimal">
<li>Coverage data (<code>f_tibble</code>)</li>
<li>Sequins metadata (<code>sequins</code>)</li>
<li>Dilution of sequins used to add into the fractions (<code>seq_dil</code>)</li>
</ol>
<p>The regression scaling plots are saved in the project folder within a subfolder <code>sequin_scaling_plots</code></p>
<pre class="r"><code>taxonomy_tibble = dplyr::bind_rows(gtdbtk_bac_summary, gtdbtk_archaea) #Combine bacteria and archaea taxonomy files if it has not been done yet
#mag_tab is a tibble with absolute concentrations of MAGs obtained by scaling MAG coverages using linear regression models on sequin coverages and concentration

##Scale MAG coverages to obtain MAG absolute concentrations and save scaling plots in the working directory
#For rlm scaling using scale_features_rlm
#For rlm scaling using scale_features_lm
mag_tab_scaled &lt;- SIPmg::scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation, save_plots = FALSE)
#&gt; Warning in rlm.default(x, y, weights, method = method, wt.method = wt.method, :
#&gt; &#39;rlm&#39; failed to converge in 20 steps
#&gt; Warning in dir.create(plot_dir): &#39;sequin_scaling_plots_rlm&#39; already exists
mag_tab = as.matrix(mag_tab_scaled$mag_tab) #Extract absolute abundances as a matrix</code></pre>
<div id="example-of-a-scaling-plot" class="section level4">
<h4>Example of a scaling plot</h4>
<p>An example of a scaling plot is as below</p>
<pre><code>#&gt; Warning: The dot-dot notation (`..rr.label..`) was deprecated in ggplot2 3.4.0.
#&gt; ℹ Please use `after_stat(rr.label)` instead.
#&gt; ℹ The deprecated feature was likely used in the SIPmg package.
#&gt;   Please report the issue to the authors.
#&gt; `geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<p><img src="/ZielsLab/SIPmg.github.io.gitpost/sipmg-vignette/SIPmg-vignette_files/figure-html/example%20scaling%20plot-1.png" width="672" /></p>
</div>
</div>
</div>
<div id="preparation-of-scaled-data-for-qsip-analysis" class="section level2">
<h2>Preparation of scaled data for qSIP analysis</h2>
<p>The scaled abundance data, taxonomy data, and metadata is then converted to phyloseq objects and a master phyloseq object is created for qSIP analysis.</p>
<pre class="r"><code>
mag.table = phyloseq::otu_table(mag_tab, taxa_are_rows = TRUE) #Phyloseq OTU table

taxonomy.object = SIPmg::tax.table(taxonomy_tibble) # Create a taxonomy phyloseq object
samples.object = SIPmg::sample.table(fractions) # Create a samples phyloseq object
phylo.qSIP = SIPmg::phylo.table(mag.table, taxonomy.object, samples.object) # Make a phyloseq table for downstream qSIP analysis</code></pre>
</div>
<div id="estimation-of-atom-fraction-excess" class="section level2">
<h2>Estimation of atom fraction excess</h2>
<p>The following steps estimate the atom fraction excess (AFE) in the MAGs. This calculation is based on the mathematical model suggested by <a href="https://journals.asm.org/doi/full/10.1128/AEM.02280-15">Hungate et al. (2015)</a>. In the article, the authors suggest that GC contents of the individual biological features of interest should be accounted for to have a better estimate of AFE. Through the power of metagenomic analysis and the recovery of MAGs, one can estimate the GC content of features of interest and thereby obtain a better estimate of AFE. Thus, here the user would use the GC contents of MAGs in the AFE estimations and obtain isotopic enrichment of individual MAGs.</p>
<p>An important consideration is that the AFE calculations are based on a mathematical model and are not an absolute estimate of isotopic enrichment. One of the goals of AFE estimation is to determine isotope incorporators.</p>
<p>In this example workflow, the approach reported in <a href="https://journals.asm.org/doi/full/10.1128/AEM.02280-15">Hungate et al. (2015)</a> is used to determine incorporators.</p>
<p>For this step, the following are used:</p>
<ol style="list-style-type: decimal">
<li>Master phyloseq object from the previous step</li>
<li>GC content</li>
</ol>
<p>Thanks to <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0189616">HTSSIP R package</a>, bootstrapping can be performed faster with multithreading.</p>
<pre class="r"><code>atomX = SIPmg::qSIP_atom_excess_MAGs(phylo.qSIP,
                               control_expr=&#39;Isotope==&quot;12C&quot;&#39;,
                               treatment_rep=&#39;Replicate&#39;,
                               Gi = GC_content)
#&gt; Warning: `mutate_()` was deprecated in dplyr 0.7.0.
#&gt; ℹ Please use `mutate()` instead.
#&gt; ℹ See vignette(&#39;programming&#39;) for more help
#&gt; ℹ The deprecated feature was likely used in the dplyr package.
#&gt;   Please report the issue at &lt;https://github.com/tidyverse/dplyr/issues&gt;.
#&gt; Warning: `select_()` was deprecated in dplyr 0.7.0.
#&gt; ℹ Please use `select()` instead.
#&gt; ℹ The deprecated feature was likely used in the dplyr package.
#&gt;   Please report the issue at &lt;https://github.com/tidyverse/dplyr/issues&gt;.
#&gt; Warning: `filter_()` was deprecated in dplyr 0.7.0.
#&gt; ℹ Please use `filter()` instead.
#&gt; ℹ See vignette(&#39;programming&#39;) for more help
#&gt; ℹ The deprecated feature was likely used in the dplyr package.
#&gt;   Please report the issue at &lt;https://github.com/tidyverse/dplyr/issues&gt;.
#&gt; Warning: `summarise_()` was deprecated in dplyr 0.7.0.
#&gt; ℹ Please use `summarise()` instead.
#&gt; ℹ The deprecated feature was likely used in the dplyr package.
#&gt;   Please report the issue at &lt;https://github.com/tidyverse/dplyr/issues&gt;.
#&gt; Warning: `group_by_()` was deprecated in dplyr 0.7.0.
#&gt; ℹ Please use `group_by()` instead.
#&gt; ℹ See vignette(&#39;programming&#39;) for more help
#&gt; ℹ The deprecated feature was likely used in the dplyr package.
#&gt;   Please report the issue at &lt;https://github.com/tidyverse/dplyr/issues&gt;.
#Bootstrap confidence intervals
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10) #Change &quot;parallel = FALSE&quot; to compute using a single-core</code></pre>
</div>
<div id="plot-the-atom-fraction-excess-plot" class="section level2">
<h2>Plot the atom fraction excess plot</h2>
<p>Plot the atom fraction excess data with 5 % and 95 % quantiles as the confidence limits. In the same way as reported in <a href="https://journals.asm.org/doi/full/10.1128/AEM.02280-15">Hungate et al. (2015)</a>, a MAG is considered an incorporator if the lower confidence interval of its AFE is above zero.</p>
<pre class="r"><code>CI_threshold = 0
df_atomX_boot = df_atomX_boot %&gt;%
  dplyr::mutate(Incorporator = A_CI_fcr_low &gt; CI_threshold,
         OTU = reorder(OTU, -A))

(atom_f_excess_plot = ggplot2::ggplot(df_atomX_boot, aes(OTU, A, ymin=A_CI_low, ymax=A_CI_high, color=Incorporator)) +
  geom_pointrange(size=0.25) +
  geom_linerange() +
  geom_hline(yintercept=0, linetype=&#39;dashed&#39;, alpha=0.5) +
  labs(x=&#39;MAGs&#39;, y=&#39;Atom fraction excess&#39;) +
  theme_bw() +
  coord_flip() +
  ggtitle(&quot;Isotope incorporating MAGs&quot;))</code></pre>
<p><img src="/ZielsLab/SIPmg.github.io.gitpost/sipmg-vignette/SIPmg-vignette_files/figure-html/Plot%20atom%20fraction%20excess-1.png" width="672" /></p>
<pre class="r"><code>ggplot2::ggsave(filename = &quot;atom_fration_excess.pdf&quot;, plot = atom_f_excess_plot)
#&gt; Saving 7 x 5 in image</code></pre>
</div>
<div id="check-incorporator-list" class="section level2">
<h2>Check incorporator list</h2>
<pre class="r"><code>
#Get incorporator info
n_incorp = df_atomX_boot %&gt;%
  dplyr::filter(Incorporator == TRUE) %&gt;%
  nrow 
#Get incorporator list
incorporator_list = SIPmg::incorporators_taxonomy(taxonomy = taxonomy_tibble, bootstrapped_AFE_table = df_atomX_boot)
#Print incorporator information
cat(&#39;Number of incorporators:&#39;, n_incorp, &#39;\n&#39;)
#&gt; Number of incorporators: 28
print(incorporator_list, n = nrow(incorporator_list))
#&gt; # A tibble: 28 × 2
#&gt;    OTU         taxonomy                       
#&gt;    &lt;fct&gt;       &lt;chr&gt;                          
#&gt;  1 NC_000913.3 Terriglobusroseus              
#&gt;  2 NC_003450.3 Segniliparusrotundus           
#&gt;  3 NC_008261.1 Nocardiopsisdassonvillei       
#&gt;  4 NC_010067.1 Olsenellauli                   
#&gt;  5 NC_014008.1 Meiothermus_Bsilvanus          
#&gt;  6 NC_014168.1 Meiothermus_Bsilvanus          
#&gt;  7 NC_014210.1 Hungateiclostridiumthermocellum
#&gt;  8 NC_014211.1 Clostridium_Pperfringens       
#&gt;  9 NC_014212.1 Desulfosporosinusacidiphilus   
#&gt; 10 NC_014213.1 Desulfosporosinusacidiphilus   
#&gt; 11 NC_014214.1 Desulfosporosinusacidiphilus   
#&gt; 12 NC_014363.1 Desulfosporosinusmeridiei      
#&gt; 13 NC_015761.1 Streptococcuspyogenes          
#&gt; 14 NC_017033.1 Thermobacilluscomposti         
#&gt; 15 NC_018014.1 Hirschiabaltica                
#&gt; 16 NC_018066.1 Hirschiabaltica                
#&gt; 17 NC_018068.1 Salmonellaarizonae             
#&gt; 18 NC_019792.1 Pseudomonas_Astutzeri_AE       
#&gt; 19 NC_019897.1 Pseudomonas_Astutzeri_AE       
#&gt; 20 NC_019936.1 Frateuriaaurantia              
#&gt; 21 NC_019937.1 Sediminispirochaetasmaragdinae 
#&gt; 22 NC_019938.1 Fervidobacteriumpennivorans    
#&gt; 23 NC_019939.1 Coraliomargaritaakajimensis    
#&gt; 24 NC_019964.1 Halovivaxruber                 
#&gt; 25 NC_019974.1 Natronobacteriumgregoryi       
#&gt; 26 NC_019975.1 Natronococcusoccultus          
#&gt; 27 NC_019976.1 Natronococcusoccultus          
#&gt; 28 NC_021184.1 Natronococcusoccultus</code></pre>
<p>It appears that not all incorporators were identified with the bootstrapping method. This could be due to the model unable to detect the incorporators. Another way to detect incorporators, as mentioned above, is to test with the ΔBD method or with the HR-SIP or MW-HR-SIP methods. For a more detailed discussion, please refer this <a href="#sip-metagenomics-and-identification-of-isotope-incorporators">vignette</a></p>
</div>
</div>
<div id="scaling-coverage-data" class="section level1">
<h1>Scaling coverage data</h1>
<p>In this example we will look at the two scaling approaches that can be utilized in the SIPmg package. The user can decide either</p>
<ol style="list-style-type: decimal">
<li>A robust linear regression model</li>
<li>An ordinary least squares linear regression model
We will also briefly discuss data filtering methods when there are heavily influencing outliers, as a result of upstream methods.</li>
</ol>
<div id="basic-approach-for-scaling" class="section level2">
<h2>Basic approach for scaling</h2>
<p>Sequencing effort on each fraction and subsequently obtained coverage is typically used to estimate relative abundance for a feature of interest. However, as we discussed in the introductory vignette, this data is compositional and a quantitative estimate of concentrations can be highly informative. For this purpose, synthetic spike-in standards (sequins) with known concentrations are added before recovery of fractionated DNA, from the CsCl medium into TE buffer or water. For details on sequins please refer to <a href="https://www.nature.com/articles/s41467-018-05555-0">Hardwick et al. (2018)</a>. These reference standards in each fraction, can now be used to estimate the concentration of the feature of interest in each fraction.</p>
<p>The approach used for scaling is detailed in the following steps:</p>
<ol style="list-style-type: decimal">
<li><p>For each fraction, sequin coverages and known concentrations are obtained to make a standard curve.</p></li>
<li><p>Limit of detection of sequins, i.e., the lowest concentration where at least one sequin has detectable coverage, is determined for each group of sequin concentrations.</p></li>
<li><p>For each group of sequin concentrations, mean, standard deviation, and the coefficient of variation of coverage are determined. Groups of sequins with coefficient of variation greater than the set threshold will be flagged.</p></li>
<li><p>Sequin groups with coverage values above the limit of detection and below the coefficient of variation threshold are filtered in preparation for regression.</p></li>
<li><p>Linear regression or robust linear regression, based on the user choice, is performed on sequin coverage values as the independent variable and concentration of the sequin group as the dependent variable. The user can also decide on performing log scaling of coverage and concentration values for regression.</p></li>
<li><p>The regression parameters are extracted and plots with regression parameters and best fit line are saved for inspection.</p></li>
<li><p>Coverage values above the limit of detection and below the coefficient of variation threshold are filtered for further analysis. The rest of the values are flagged and reported.</p></li>
<li><p>The filtered values are scaled based on regression parameters to estimate absolute concentrations in each library.</p></li>
<li><p>Absolute concentrations of biological features are saved as a fresh dataset for the subsequent isotope incorporator identification and AFE estimation pipeline.</p></li>
</ol>
</div>
<div id="choice-of-regression-model" class="section level2">
<h2>Choice of regression model</h2>
<p>Ordinary least squares regression can be very sensitive to outliers, resulting a poor model performance when the data is contaminated with outliers. Although there are methods, like Cook’s distance based filtering to address outliers, it may not always be the best idea to remove these data points.</p>
<p>See <a href="https://statisticsbyjim.com/basics/remove-outliers/">these</a> <a href="https://stats.stackexchange.com/questions/175/how-should-outliers-be-dealt-with-in-linear-regression-analysis">discussions</a> and more for better insights into handling outliers.</p>
<p>Robust linear regression is an alternative to this situation. Robust linear regression assigns appropriate weights to the data points, minimizing the influence of outliers on the model performance, without deleting data. In this pipeline, a Huber loss function from the <a href="https://cran.r-project.org/web/packages/MASS/MASS.pdf"><code>MASS</code> R package</a> was used for robust linear regression.</p>
<p>The user is free to choose between the two methods for regression.</p>
</div>
<div id="scaling-the-data" class="section level2">
<h2>Scaling the data</h2>
<p>For illustrating the differences in the regression models, a different dataset, that was impacted by one or many upstream methods, will be used than the one in the introductory vignette.</p>
<p>This dataset can be found here</p>
<pre><code>#&gt; Rows: 86 Columns: 6
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): Feature
#&gt; dbl (5): 52434.2.332926.AAAGGCGT-TCAACTCC, 52434.2.332926.GCAGTGAA-ACATTCGG,...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 80 Columns: 2
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): Feature
#&gt; dbl (1): Concentration
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 5 Columns: 2
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): Sample
#&gt; dbl (1): Dilution
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<p>For both scaling functions the following data and parameters are required</p>
<ol style="list-style-type: decimal">
<li><p>Coverage data. The output of <a href="https://github.com/Ecogenomics/CheckM/wiki/Utility-Commands#coverage">checkm coverage</a> command can be directly used.</p></li>
<li><p>Sequin dilutions and metadata.</p></li>
<li><p>Whether or not log10 scaling to be performed (a BOOLEAN value of TRUE or FALSE).</p></li>
<li><p>Coefficient of variation. In this dataset, a higher coefficient of variation compared to the value used in the example workflow of the <a href="#using-sipmg-r-package">introduction vignette</a> is used to allow data scaling to occur.</p></li>
</ol>
<p>If the robust linear regression is chosen, the function is <code>scale_features_rlm</code> which is performed the function file <code>sequin_scaling_rlm.R</code>.</p>
<pre class="r"><code>mag_tab_scaled_rlm &lt;- SIPmg::scale_features_rlm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation, save_plots = FALSE)
#&gt; Warning in rlm.default(x, y, weights, method = method, wt.method = wt.method, :
#&gt; &#39;rlm&#39; failed to converge in 20 steps
#&gt; Warning in dir.create(plot_dir): &#39;sequin_scaling_plots_rlm&#39; already exists</code></pre>
<p>If a linear regression is chosen, the function is <code>scale_features_lm</code> which is performed by the function file <code>sequin_scaling_lm.R</code>.</p>
<p>If the user chooses linear regression, they can choose to perform outlier filtering based on the traditional Cook’s distance threshold of 4/n (n being the sample size). Only the outliers in the sequin coverage data are flagged as outliers with the Cook’s distance threshold and are filtered out. Later, the remaining data is subjected to linear regression to obtain model parameters and to scale coverage values of feature of interest.</p>
<pre class="r"><code>mag_tab_scaled_lm &lt;- SIPmg::scale_features_lm(f_tibble, sequins, seq_dil, log_scale, coe_of_variation = coe_of_variation, cook_filtering = TRUE, save_plots = FALSE)
#&gt; Warning in summary.lm(.): essentially perfect fit: summary may be unreliable

#&gt; Warning in summary.lm(.): essentially perfect fit: summary may be unreliable

#&gt; Warning in summary.lm(.): essentially perfect fit: summary may be unreliable

#&gt; Warning in summary.lm(.): essentially perfect fit: summary may be unreliable
#&gt; Warning in dir.create(plot_dir): &#39;sequin_scaling_plots_lm&#39; already exists
#&gt; Warning in file.remove(plot_dir): cannot remove file &#39;sequin_scaling_plots_lm&#39;,
#&gt; reason &#39;Permission denied&#39;</code></pre>
</div>
<div id="comparison-of-the-fits" class="section level2">
<h2>Comparison of the fits</h2>
<p>Robust linear regression provides a better model fit compared to the linear regression. Additionally, robust linear regression has less variability compared to the linear regression model.</p>
<pre class="r"><code># Robust linear regression plot
EBImage::display(rlm_example)</code></pre>
<p><img src="/ZielsLab/SIPmg.github.io.gitpost/sipmg-vignette/SIPmg-vignette_files/figure-html/show%20images-1.png" width="672" /></p>
<pre class="r"><code>
#Linear regression plot without filtering sequin data
EBImage::display(lm_example)</code></pre>
<p><img src="/ZielsLab/SIPmg.github.io.gitpost/sipmg-vignette/SIPmg-vignette_files/figure-html/show%20images-2.png" width="672" /></p>
<p>As discussed previously, removing the outliers may not always be the best idea. However, the outliers can be visualized to assess how “far out” are the outliers and how influential the data points are, negatively influencing the linear regression method.</p>
<p>The <code>mag_tab_scaled_lm</code> function provides the plots for the visualization of Cook’s distance for the sequin data in each fraction. In the plot below, an outlier is visualized. For this data, the Cook’s distance threshold was 0.09, and the outlier had a Cook’s distance of 10.8. The highly influential data point could well be the reason the linear regression model had a poor fit.</p>
<pre class="r"><code>
#Cook&#39;s distance threshold of the data set
4/(length(mag_tab_scaled_lm$scale_fac$cooksd[[3]]))
#&gt; [1] 0.1142857

#Cook&#39;s distance of the outlier before filtering the data
max(mag_tab_scaled_lm$scale_fac$cooksd[[3]])
#&gt; [1] 0.3588489

#Before filtration
EBImage::display(cooksd_example)</code></pre>
<p><img src="/ZielsLab/SIPmg.github.io.gitpost/sipmg-vignette/SIPmg-vignette_files/figure-html/outlier%20sequin%20coverages-1.png" width="672" /></p>
<p>Upon filtering the data to remove the outlier, the fit becomes much better for the linear regression model</p>
<pre class="r"><code>#Linear regression plot with filtered outliers in sequin data
EBImage::display(filtered_lm_example)</code></pre>
<p><img src="/ZielsLab/SIPmg.github.io.gitpost/sipmg-vignette/SIPmg-vignette_files/figure-html/better%20fit-1.png" width="672" /></p>
</div>
<div id="what-if-there-were-no-sequins-added-in-the-study" class="section level2">
<h2>What if there were no sequins added in the study</h2>
<p>In our study, we realized that the sequin-scaled data provided the best correlation (Spearman correlation coefficient = 0.85), compared to methods without the use of sequins. However, not all studies would have access to sequins or could choose not to add sequins. We tested qSIP methods with absolute concentration of MAGs obtained as a product of fraction DNA concentration and either with MAG relative abundance (as performed by <a href="https://journals.asm.org/doi/10.1128/mSystems.00151-20">Greenlon et al.</a>) or relative coverage (as performed by <a href="https://journals.asm.org/doi/10.1128/mSphere.00085-21">Starr et al.</a>), or simply with relative coverage, i.e., without converting the MAG coverages to absolute concentration. We found that without sequins, simply using relative coverage provided better specificity (0.99) and good correlation (Spearman correlation coefficient = 0.76), compared to the other two methods. The user could choose any of the three approaches to obtain normalized coverages using the equation <code>coverage_normalization()</code> where the parameter approach would be chosen accordingly (either “greenlon”, “starr”, or “relative_coverage”). In this example, simple relative coverage will be estimated without converting to absolute concentration based on fraction DNA concentrations. The relative coverage table can then be converted to a phyloseq object to run incorporator identification and/or AFE estimation. For more details, please refer to the <a href="#sip-metagenomics-and-identification-of-isotope-incorporators">incorporator identification section</a></p>
<pre class="r"><code>f_tibble &lt;- readr::read_csv(&quot;mock_input_data/coverage_metadata.csv&quot;)
#&gt; Rows: 124 Columns: 61
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr  (1): Feature
#&gt; dbl (60): 12C_rep_1_fraction_10, 12C_rep_1_fraction_1, 12C_rep_1_fraction_2,...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
rel.cov = SIPmg::coverage_normalization(f_tibble = f_tibble, approach = &quot;relative_coverage&quot;)
mag.table = phyloseq::otu_table(as.matrix(rel.cov %&gt;% tibble::column_to_rownames(var = &quot;Feature&quot;)), taxa_are_rows = TRUE) #Phyloseq OTU table</code></pre>
</div>
<div id="decision-on-the-method-to-scale-coverages" class="section level2">
<h2>Decision on the method to scale coverages</h2>
<p>It can be seen from the above plots that the regression parameters differ based on the method of regression and whether or not data filtering is used. These regression parameters directly influence the estimation of concentrations of features of interest in the microbiome. Thus, the method for regression must be a careful choice.</p>
</div>
</div>
<div id="sip-metagenomics-and-identification-of-isotope-incorporators" class="section level1">
<h1>SIP metagenomics and identification of isotope incorporators</h1>
<p>The isotope incorporators could be identified using the below methods:</p>
<ul>
<li>AFE mathematical model by <a href="https://journals.asm.org/doi/10.1128/AEM.02280-15">Hungate et al. (2015)</a> or
<ul>
<li>Delta buoyant density <span class="math inline">\(AFE_{ΔBD}\)</span> = <span class="math inline">\(\frac{W_{Lab}- W_{Light}}{I_{max}}\)</span>. Where <span class="math inline">\(I_{max}\)</span> is the maximum linear shift in DNA BD (upon 100% labeling), as discussed by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2595786/">Birnie and Rickwood (1978)</a></li>
<li>MW-HR-SIP <a href="https://www.frontiersin.org/articles/10.3389/fmicb.2018.00570/full">Youngblut et al. </a></li>
</ul></li>
</ul>
<p>While the first two methods gives a quantitative estimate of isotopic enrichment in a taxon to determine if it is an incorporator, the third method relies on differential abundance analysis over multiple overlapping windows. Please refer to Youngblut et al. and <a href="https://cran.r-project.org/web/packages/HTSSIP/index.html">HTS-SIP R package</a> for more details.</p>
<div id="comparison-of-the-methods" class="section level2">
<h2>Comparison of the methods</h2>
<div id="afe-method" class="section level3">
<h3>AFE method</h3>
<p>Isotope incorporators from the introductory vignette were identified using the AFE method
Reproducing the code here, we have</p>
<pre><code>#&gt; Rows: 124 Columns: 61
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr  (1): Feature
#&gt; dbl (60): 12C_rep_1_fraction_10, 12C_rep_1_fraction_1, 12C_rep_1_fraction_2,...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 115 Columns: 5
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (2): Feature, Sequence
#&gt; dbl (3): Length, GC_content, Concentration
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 60 Columns: 2
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): Sample
#&gt; dbl (1): Dilution
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 33 Columns: 19
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;\t&quot;
#&gt; chr  (2): user_genome, classification
#&gt; lgl (17): fastani_reference, fastani_reference_radius, fastani_taxonomy, fas...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 5 Columns: 19
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;\t&quot;
#&gt; chr  (2): user_genome, classification
#&gt; lgl (17): fastani_reference, fastani_reference_radius, fastani_taxonomy, fas...
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 38 Columns: 2
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (1): OTU
#&gt; dbl (1): Gi
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
#&gt; Rows: 60 Columns: 6
#&gt; ── Column specification ────────────────────────────────────────────────────────
#&gt; Delimiter: &quot;,&quot;
#&gt; chr (2): Isotope, Sample
#&gt; dbl (4): Replicate, Fraction, Buoyant_density, DNA_concentration(ng/uL)
#&gt; 
#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.
#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>#&gt; Warning in dir.create(plot_dir): &#39;sequin_scaling_plots_lm&#39; already exists
#&gt; Warning in file.remove(plot_dir): cannot remove file &#39;sequin_scaling_plots_lm&#39;,
#&gt; reason &#39;Permission denied&#39;</code></pre>
<pre class="r"><code>atomX = SIPmg::qSIP_atom_excess_MAGs(phylo.qSIP,
                               control_expr=&#39;Isotope==&quot;12C&quot;&#39;,
                               treatment_rep=&#39;Replicate&#39;,
                               Gi = GC_content)
#Bootstrap confidence intervals
df_atomX_boot = SIPmg::qSIP_bootstrap_fcr(atomX, n_boot=10)
CI_threshold = 0
df_atomX_boot = df_atomX_boot %&gt;%
  dplyr::mutate(Incorporator_qSIP = A_CI_fcr_low &gt; CI_threshold,
                Incorporator_delbd = A_delbd - A_delbd_sd &gt; 0,
         OTU = stats::reorder(OTU, -A))

df_atomX_boot = df_atomX_boot %&gt;%
  dplyr::inner_join(taxonomy_tibble %&gt;% 
               dplyr::select(user_genome, classification) %&gt;%
               dplyr::rename(OTU = user_genome)) 
#&gt; Joining, by = &quot;OTU&quot;</code></pre>
</div>
<div id="mw-hr-sip" class="section level3">
<h3>MW-HR-SIP</h3>
<p>Check incorporators in the overlapping windows of 1.71 - 1.74; 1.72 - 1.75; 1.73 - 1.76. The windows must be chosen in a more judicious manner that fits the hypothesis of the study.</p>
<pre class="r"><code>windows = data.frame(density_min=c(1.71,1.72, 1.73), 
                     density_max=c(1.74,1.75,1.76))

padj_cutoff = 0.05
#ncores = 6
#doParallel::registerDoParallel(ncores)

mw.hr.sip = SIPmg::HRSIP(physeq = phylo.qSIP, design = ~Isotope,
                                    density_windows = windows,
                                    sparsity_threshold = seq(0, 0.3, 0.05), 
                                    padj_cutoff = padj_cutoff)
#&gt; Sparsity threshold: 0 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.05 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.1 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.15 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.2 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.25 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.3 
#&gt; Density window: 1.71-1.74
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.05 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.1 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.15 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.2 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.25 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.3 
#&gt; Density window: 1.72-1.75
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.05 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.1 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.15 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.2 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.25 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold: 0.3 
#&gt; Density window: 1.73-1.76
#&gt; converting counts to integer mode
#&gt; Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in
#&gt; design formula are characters, converting to factors
#&gt; Sparsity threshold with the most rejected hypotheses: 0

mw.hr.sip = mw.hr.sip %&gt;%
  dplyr::mutate(incorp = padj &lt; padj_cutoff)
</code></pre>
<p>Compare number of incorporators</p>
<pre class="r"><code>#Get incorporator info
qSIP_incorp = df_atomX_boot %&gt;%
  dplyr::select(OTU, classification, A, A_sd, Incorporator_qSIP) %&gt;%
  dplyr::filter(Incorporator_qSIP == TRUE) %&gt;%
  dplyr::select(-classification)
n_qSIP_incorp = nrow(qSIP_incorp)

delbd_incorp = df_atomX_boot %&gt;%
  dplyr::select(OTU, classification, A_delbd, A_delbd_sd, Incorporator_delbd) %&gt;%
  dplyr::filter(Incorporator_delbd == TRUE) %&gt;%
  dplyr::select(-classification)
n_delbd_incorp = nrow(delbd_incorp)

mw.hr.sip_incorp = mw.hr.sip %&gt;%
  dplyr::select(OTU, taxa, incorp) %&gt;%
  dplyr::filter(incorp == TRUE) %&gt;%
  dplyr::rename(&quot;Incorporator_mw_hr.sip&quot; = &quot;incorp&quot;) %&gt;%
  dplyr::select(-taxa)
n_mw.hr.sip_incorp = nrow(mw.hr.sip_incorp)

all_incorp_tibble = dplyr::full_join(qSIP_incorp, dplyr::full_join(delbd_incorp, mw.hr.sip_incorp, by = &quot;OTU&quot;), by = &quot;OTU&quot;)

#Print incorporator information
cat(&#39;Number of incorporators detected by qSIP:&#39;, n_qSIP_incorp, &#39;\n&#39;)
#&gt; Number of incorporators detected by qSIP: 25
cat(&#39;Number of incorporators detected by ΔBD:&#39;, n_delbd_incorp, &#39;\n&#39;)
#&gt; Number of incorporators detected by ΔBD: 25
cat(&#39;Number of incorporators detected by MW-HR-SIP:&#39;, n_mw.hr.sip_incorp, &#39;\n&#39;)
#&gt; Number of incorporators detected by MW-HR-SIP: 6

rmarkdown::paged_table(all_incorp_tibble)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":["OTU"],"name":[1],"type":["chr"],"align":["left"]},{"label":["A"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["A_sd"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Incorporator_qSIP"],"name":[4],"type":["lgl"],"align":["right"]},{"label":["A_delbd"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["A_delbd_sd"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["Incorporator_delbd"],"name":[7],"type":["lgl"],"align":["right"]},{"label":["Incorporator_mw_hr.sip"],"name":[8],"type":["lgl"],"align":["right"]}],"data":[{"1":"NC_000913.3","2":"0.01559359","3":"0.002091374","4":"TRUE","5":"0.02406311","6":"0.003225629","7":"TRUE","8":"NA"},{"1":"NC_003450.3","2":"0.04847647","3":"0.003708503","4":"TRUE","5":"0.07472437","6":"0.005715178","7":"TRUE","8":"NA"},{"1":"NC_008261.1","2":"0.40987487","3":"0.005120050","4":"TRUE","5":"0.62217710","6":"0.007671753","7":"TRUE","8":"TRUE"},{"1":"NC_010067.1","2":"0.02115236","3":"0.002669788","4":"TRUE","5":"0.03263313","6":"0.004116374","7":"TRUE","8":"NA"},{"1":"NC_014008.1","2":"0.05571908","3":"0.001253195","4":"TRUE","5":"0.08588456","6":"0.001929710","7":"TRUE","8":"NA"},{"1":"NC_014168.1","2":"0.19241466","3":"0.002746633","4":"TRUE","5":"0.29510881","6":"0.004188570","7":"TRUE","8":"NA"},{"1":"NC_014210.1","2":"0.26572526","3":"0.001003649","4":"TRUE","5":"0.40677094","6":"0.001531631","7":"TRUE","8":"NA"},{"1":"NC_014211.1","2":"0.25457996","3":"0.004842409","4":"TRUE","5":"0.38969078","6":"0.007368179","7":"TRUE","8":"NA"},{"1":"NC_014212.1","2":"0.17145305","3":"0.013829994","4":"TRUE","5":"0.26328878","6":"0.021166596","7":"TRUE","8":"NA"},{"1":"NC_014213.1","2":"0.18323983","3":"0.009626021","4":"TRUE","5":"0.28122785","6":"0.014749334","7":"TRUE","8":"NA"},{"1":"NC_014214.1","2":"0.17572222","3":"0.005484273","4":"TRUE","5":"0.26974532","6":"0.008401266","7":"TRUE","8":"NA"},{"1":"NC_014363.1","2":"0.18240538","3":"0.003724266","4":"TRUE","5":"0.27994855","6":"0.005718211","7":"TRUE","8":"NA"},{"1":"NC_015761.1","2":"0.02075433","3":"0.001495422","4":"TRUE","5":"0.03202098","6":"0.002306621","7":"TRUE","8":"NA"},{"1":"NC_017033.1","2":"0.17788410","3":"0.004758109","4":"TRUE","5":"0.27309952","6":"0.007294859","7":"TRUE","8":"NA"},{"1":"NC_018014.1","2":"0.11933315","3":"0.002381048","4":"TRUE","5":"0.18348339","6":"0.003649853","7":"TRUE","8":"NA"},{"1":"NC_019792.1","2":"0.15582689","3":"0.001729569","4":"TRUE","5":"0.23937276","6":"0.002645053","7":"TRUE","8":"NA"},{"1":"NC_019897.1","2":"0.12756736","3":"0.002739246","4":"TRUE","5":"0.19611237","6":"0.004202457","7":"TRUE","8":"NA"},{"1":"NC_019936.1","2":"0.15923443","3":"0.003366670","4":"TRUE","5":"0.24457921","6":"0.005160172","7":"TRUE","8":"NA"},{"1":"NC_019937.1","2":"0.05922982","3":"0.003018288","4":"TRUE","5":"0.09129203","6":"0.004646234","7":"TRUE","8":"NA"},{"1":"NC_019938.1","2":"0.10114853","3":"0.004781642","4":"TRUE","5":"0.15558613","6":"0.007352333","7":"TRUE","8":"NA"},{"1":"NC_019939.1","2":"0.16398224","3":"0.011721812","4":"TRUE","5":"0.25182466","6":"0.017927258","7":"TRUE","8":"NA"},{"1":"NC_019964.1","2":"0.18205895","3":"0.003576154","4":"TRUE","5":"0.27942488","6":"0.005476378","7":"TRUE","8":"NA"},{"1":"NC_019974.1","2":"0.17720421","3":"0.002021406","4":"TRUE","5":"0.27195722","6":"0.003094519","7":"TRUE","8":"NA"},{"1":"NC_019975.1","2":"0.06581470","3":"0.012121626","4":"TRUE","5":"0.10139967","6":"0.018645191","7":"TRUE","8":"NA"},{"1":"NC_019976.1","2":"0.12916152","3":"0.001744027","4":"TRUE","5":"0.19853018","6":"0.002670578","7":"TRUE","8":"NA"},{"1":"NC_002737.2","2":"NA","3":"NA","4":"NA","5":"NA","6":"NA","7":"NA","8":"TRUE"},{"1":"NC_009012.1","2":"NA","3":"NA","4":"NA","5":"NA","6":"NA","7":"NA","8":"TRUE"},{"1":"NC_017095.1","2":"NA","3":"NA","4":"NA","5":"NA","6":"NA","7":"NA","8":"TRUE"},{"1":"NC_018066.1","2":"NA","3":"NA","4":"NA","5":"NA","6":"NA","7":"NA","8":"TRUE"},{"1":"NC_018515.1","2":"NA","3":"NA","4":"NA","5":"NA","6":"NA","7":"NA","8":"TRUE"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>It is evident here that the AFE estimates using qSIP model or the ΔBD method are not the same, however, both provide the same incorporator information. Although the incorporators may not be the same everytime, we found an overlap between qSIP and ΔBD methods in our metagenome datasets. We also found that qSIP model provided more accurate estimates of AFE compared to ΔBD method.

It also appears that MW-HR-SIP outputs lower number of incorporators. In our study and by <a href="https://www.frontiersin.org/articles/10.3389/fmicb.2018.00570/full">Youngblut et al.</a>, MW-HR-SIP was found to have better sensitivity compared to qSIP or ΔBD methods. It is interesting that the AFE based methods and differential abundance based methods do not provide the same incorporator identity, which is perhaps due to comparistive analysis in only the multiple overlapping windows in the MW-HR-SIP method, while the AFE methods examine the complete BD gradient. Due to the higher sensitivity of the MW-HR-SIP method, we attempted a sequential analysis with first MW-HR-SIP to eliminate likely false positives, and then perform qSIP to estimate AFE. Such a method reduces multiple comparisons and increases confidence in detecting true incorporators due to higher statistical power.

We are merely providing the different methods for the user to decide which method to apply for detecting incorporators in their study. The choice of the method is to the user’s discretion that fits best their study.
## Session information</p>
<pre class="r"><code>sessionInfo()
#&gt; R version 4.2.2 (2022-10-31 ucrt)
#&gt; Platform: x86_64-w64-mingw32/x64 (64-bit)
#&gt; Running under: Windows 10 x64 (build 19044)
#&gt; 
#&gt; Matrix products: default
#&gt; 
#&gt; locale:
#&gt; [1] LC_COLLATE=English_Canada.utf8  LC_CTYPE=English_Canada.utf8   
#&gt; [3] LC_MONETARY=English_Canada.utf8 LC_NUMERIC=C                   
#&gt; [5] LC_TIME=English_Canada.utf8    
#&gt; 
#&gt; attached base packages:
#&gt; [1] stats     graphics  grDevices utils     datasets  methods   base     
#&gt; 
#&gt; other attached packages:
#&gt;  [1] SIPmg_1.4           ggpubr_0.5.0        HTSSIP_1.4.1       
#&gt;  [4] phyloseq_1.42.0     forcats_0.5.2       stringr_1.5.0      
#&gt;  [7] dplyr_1.0.10        purrr_0.3.5         readr_2.1.3        
#&gt; [10] tidyr_1.2.1         tibble_3.1.8        ggplot2_3.4.0      
#&gt; [13] tidyverse_1.3.2     BiocManager_1.30.19
#&gt; 
#&gt; loaded via a namespace (and not attached):
#&gt;   [1] readxl_1.4.1                backports_1.4.1            
#&gt;   [3] systemfonts_1.0.4           plyr_1.8.8                 
#&gt;   [5] igraph_1.3.5                lazyeval_0.2.2             
#&gt;   [7] splines_4.2.2               BiocParallel_1.32.4        
#&gt;   [9] GenomeInfoDb_1.34.4         digest_0.6.30              
#&gt;  [11] foreach_1.5.2               htmltools_0.5.4            
#&gt;  [13] tiff_0.1-11                 fansi_1.0.3                
#&gt;  [15] magrittr_2.0.3              memoise_2.0.1              
#&gt;  [17] googlesheets4_1.0.1         cluster_2.1.4              
#&gt;  [19] tzdb_0.3.0                  Biostrings_2.66.0          
#&gt;  [21] annotate_1.76.0             modelr_0.1.10              
#&gt;  [23] matrixStats_0.63.0          vroom_1.6.0                
#&gt;  [25] timechange_0.1.1            jpeg_0.1-10                
#&gt;  [27] colorspace_2.0-3            blob_1.2.3                 
#&gt;  [29] rvest_1.0.3                 textshaping_0.3.6          
#&gt;  [31] haven_2.5.1                 xfun_0.35                  
#&gt;  [33] crayon_1.5.2                RCurl_1.98-1.9             
#&gt;  [35] jsonlite_1.8.4              survival_3.4-0             
#&gt;  [37] iterators_1.0.14            ape_5.6-2                  
#&gt;  [39] glue_1.6.2                  gtable_0.3.1               
#&gt;  [41] gargle_1.2.1                zlibbioc_1.44.0            
#&gt;  [43] XVector_0.38.0              DelayedArray_0.24.0        
#&gt;  [45] car_3.1-1                   Rhdf5lib_1.20.0            
#&gt;  [47] BiocGenerics_0.44.0         abind_1.4-5                
#&gt;  [49] scales_1.2.1                DBI_1.1.3                  
#&gt;  [51] rstatix_0.7.1               Rcpp_1.0.9                 
#&gt;  [53] xtable_1.8-4                bit_4.0.5                  
#&gt;  [55] stats4_4.2.2                htmlwidgets_1.5.4          
#&gt;  [57] httr_1.4.4                  RColorBrewer_1.1-3         
#&gt;  [59] ellipsis_0.3.2              farver_2.1.1               
#&gt;  [61] pkgconfig_2.0.3             XML_3.99-0.13              
#&gt;  [63] sass_0.4.4                  dbplyr_2.2.1               
#&gt;  [65] locfit_1.5-9.6              utf8_1.2.2                 
#&gt;  [67] labeling_0.4.2              polynom_1.4-1              
#&gt;  [69] tidyselect_1.2.0            rlang_1.0.6                
#&gt;  [71] reshape2_1.4.4              AnnotationDbi_1.60.0       
#&gt;  [73] munsell_0.5.0               cellranger_1.1.0           
#&gt;  [75] tools_4.2.2                 cachem_1.0.6               
#&gt;  [77] cli_3.4.1                   generics_0.1.3             
#&gt;  [79] RSQLite_2.2.19              ade4_1.7-20                
#&gt;  [81] broom_1.0.1                 fftwtools_0.9-11           
#&gt;  [83] evaluate_0.19               biomformat_1.26.0          
#&gt;  [85] fastmap_1.1.0               ragg_1.2.4                 
#&gt;  [87] yaml_2.3.6                  knitr_1.41                 
#&gt;  [89] bit64_4.0.5                 fs_1.5.2                   
#&gt;  [91] KEGGREST_1.38.0             nlme_3.1-160               
#&gt;  [93] xml2_1.3.3                  compiler_4.2.2             
#&gt;  [95] rstudioapi_0.14             png_0.1-8                  
#&gt;  [97] ggsignif_0.6.4              reprex_2.0.2               
#&gt;  [99] geneplotter_1.76.0          bslib_0.4.2                
#&gt; [101] stringi_1.7.8               highr_0.10                 
#&gt; [103] blogdown_1.15               lattice_0.20-45            
#&gt; [105] Matrix_1.5-3                vegan_2.6-4                
#&gt; [107] permute_0.9-7               multtest_2.54.0            
#&gt; [109] vctrs_0.5.1                 pillar_1.8.1               
#&gt; [111] lifecycle_1.0.3             rhdf5filters_1.10.0        
#&gt; [113] jquerylib_0.1.4             data.table_1.14.6          
#&gt; [115] bitops_1.0-7                GenomicRanges_1.50.1       
#&gt; [117] R6_2.5.1                    bookdown_0.31              
#&gt; [119] IRanges_2.32.0              codetools_0.2-18           
#&gt; [121] MASS_7.3-58.1               assertthat_0.2.1           
#&gt; [123] rhdf5_2.42.0                SummarizedExperiment_1.28.0
#&gt; [125] DESeq2_1.38.1               withr_2.5.0                
#&gt; [127] S4Vectors_0.36.1            GenomeInfoDbData_1.2.9     
#&gt; [129] EBImage_4.40.0              mgcv_1.8-41                
#&gt; [131] parallel_4.2.2              hms_1.1.2                  
#&gt; [133] grid_4.2.2                  rmarkdown_2.19             
#&gt; [135] MatrixGenerics_1.10.0       carData_3.0-5              
#&gt; [137] googledrive_2.0.0           Biobase_2.58.0             
#&gt; [139] lubridate_1.9.0</code></pre>
</div>
</div>
</div>
